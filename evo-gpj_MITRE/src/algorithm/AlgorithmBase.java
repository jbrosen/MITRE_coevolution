/**
 * Copyright (c) 2011-2012 Evolutionary Design and Optimization Group
 * 
 * Licensed under the MIT License.
 * 
 * See the "LICENSE" file for a copy of the license.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.  
 *
 */
package algorithm;

import fitness.BooleanFitness;
import fitness.CSVData;
import fitness.Data;
import fitness.FitnessFunction;
import fitness.FunctionData;
import fitness.SRFitness;
import fitness.SemanticFitness;
import fitness.SemanticMajority;
import fitness.SemanticOrder;
import fitness.TaxCodeFitness;
import fitness.TaxFitness;
import genotype.Tree;
import gp.GPException;
import gp.Individual;
import gp.MersenneTwisterFast;
import gp.Population;

import interpreter.misc.Graph;
import interpreter.misc.writeFile;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.Random;

import operator.ListInitialize;
import operator.BroodSelection;
import operator.Crossover;
import operator.DummyEqualizer;
import operator.DummyTreeEqualizer;
import operator.Equalizer;
import operator.Initialize;
import operator.ListMutate;
import operator.ListSinglePointCrossover;
import operator.Mutate;
import operator.Select;
import operator.SinglePointCrossover;
import operator.SubtreeMutate;
import operator.TournamentEqualization;
import operator.TournamentSelection;
import operator.TreeDynamicEqualizer;
import operator.TreeInitialize;

/**
 * This contains the main method that runs the entire GP algorithm.
 * 
 * @author Owen Derby
 **/
public class AlgorithmBase {

	public static writeFile wf;
	public static final boolean VERBOSE = false;
    public static String grammarFile;
	protected double MUTATION_RATE = 0.10;
	protected double XOVER_RATE = 0.7;
	protected int ELITE = 2;
	protected int TOURNEY_SIZE = 2;
	protected int POP_SIZE = 2;
	protected int NUM_GENS = 10;
	protected static int NUM_TRIALS = 1;
	protected int BIN_WIDTH = 5;
	// Quintic polynomial x + x^2 + x^3 + x^3 + x^4 + x^5
	protected String QUINTIC = "(+ X1 (+ (* X1 X1) (+ (* X1 (* X1 X1)) (+ (* (* X1 X1) (* X1 X1)) (* X1 (* (* X1 X1) (* X1 X1)))))))";
	// protected String TRUE = "(or X1 (not X1))";
	protected String PROBLEM = QUINTIC;
	protected String PROBLEM_TYPE = "TaxFunction";
	protected int PROBLEM_SIZE = 10;
	protected List<String> FUNC_SET;
	protected List<String> TERM_SET;
	protected int TREE_INITIAL_MAX_DEPTH = 10;
	protected int TREE_MUTATE_MAX_DEPTH = 17;
	protected int TREE_XOVER_MAX_DEPTH = 17;
	protected int TREE_XOVER_TRIES = 10;
	protected int BROOD_SIZE = 1;
	protected int PNORM = 2;
	protected boolean PHENOTYPE_DOUBLE = true;
	protected int MAX_PRODUCTION_CHOICES = 100;
	
	
	protected String MUTATE = "operator.ListMutate";
//	protected String FITNESS = "fitness.TaxFitness";
	protected String FITNESS = "fitness.TaxCodeFitness";
	
	protected String SELECT = "operator.TournamentSelection";
	protected String INITIALIZE = "operator.ListInitialize";
	protected String EQUALIZER = "operator.DummyEqualizer";
	protected String XOVER = "operator.ListSinglePointCrossover";

	/**
	 * Pointer to the last complete population generated by the algorithm, which
	 * is used to generate (via genetic operators) the next generation of
	 * individuals
	 */
	protected Population pop;
	protected MersenneTwisterFast rand;
	protected Crossover xover;
	protected Select select;
	protected Mutate mutate;
	protected FitnessFunction fitness;
	protected Initialize initialize;
	protected Equalizer equalizer;

	/**
	 * Read parameters from the Property object and set Algorithm variables.
	 */
	protected void loadParams(Properties props) {
		if (props.containsKey("elite"))
			ELITE = Integer.valueOf(props.getProperty("elite"));
		if (props.containsKey("bin_width"))
			BIN_WIDTH = Integer.valueOf(props.getProperty("bin_width"));
		if (props.containsKey("mutation_rate"))
			MUTATION_RATE = Double.valueOf(props.getProperty("mutation_rate"));
		if (props.containsKey("xover_rate"))
			XOVER_RATE = Double.valueOf(props.getProperty("xover_rate"));
		if (props.containsKey("tourney_size"))
			TOURNEY_SIZE = Integer.valueOf(props.getProperty("tourney_size"));
		if (props.containsKey("brood_size"))
			BROOD_SIZE = Integer.valueOf(props.getProperty("brood_size"));
		if (props.containsKey("pop_size"))
			POP_SIZE = Integer.valueOf(props.getProperty("pop_size"));
		if (props.containsKey("num_gens"))
			NUM_GENS = Integer.valueOf(props.getProperty("num_gens"));
		// if (props.containsKey("num_trials"))
		// NUM_TRIALS = Integer.valueOf(props.getProperty("num_trials"));
		if (props.containsKey("problem"))
			PROBLEM = props.getProperty("problem");
		if (props.containsKey("problem_type"))
			PROBLEM_TYPE = props.getProperty("problem_type");
		if (props.containsKey("problem_size"))
			PROBLEM_SIZE = Integer.parseInt(props.getProperty("problem_size"));
		
		//add functions to tree
		if (props.containsKey("function_set")) {
			String funcs[] = props.getProperty("function_set").split(" ");
			FUNC_SET = new ArrayList<String>();
			for (int i = 0; i < funcs.length; i++)
				FUNC_SET.add(funcs[i]);
		}
		//add terminals to construct tree.
		if (props.containsKey("terminal_set")) {
			String term = props.getProperty("terminal_set");
			if (term.equalsIgnoreCase("all")) {
				TERM_SET = null;
			} else {
				String terms[] = term.split(" ");
				TERM_SET = new ArrayList<String>();
				for (int i = 0; i < terms.length; i++)
					
					TERM_SET.add(terms[i]);
			}
		}
		
		if (props.containsKey("tree_initial_max_depth"))
			TREE_INITIAL_MAX_DEPTH = Integer.valueOf(props
					.getProperty("tree_initial_max_depth"));
		if (props.containsKey("tree_mutate_max_depth"))
			TREE_MUTATE_MAX_DEPTH = Integer.valueOf(props
					.getProperty("tree_mutate_max_depth"));
		if (props.containsKey("tree_xover_max_depth"))
			TREE_XOVER_MAX_DEPTH = Integer.valueOf(props
					.getProperty("tree_xover_max_depth"));
		if (props.containsKey("tree_xover_tries"))
			TREE_XOVER_TRIES = Integer.valueOf(props
					.getProperty("tree_xover_tries"));
		
		if (props.containsKey("mutate_op"))
			MUTATE = props.getProperty("mutate_op");
		if (props.containsKey("xover_op"))
			XOVER = props.getProperty("xover_op");
		if (props.containsKey("selection_op"))
			SELECT = props.getProperty("selection_op");
		if (props.containsKey("fitness_op"))
			FITNESS = props.getProperty("fitness_op");
		if (props.containsKey("fitness_pnorm"))
			PNORM = Integer.valueOf(props.getProperty("fitness_pnorm"));
		if (props.containsKey("fitness_as_double"))
			PHENOTYPE_DOUBLE = Boolean.getBoolean(props
					.getProperty("fitness_as_double"));
		if (props.containsKey("initialize_op"))
			INITIALIZE = props.getProperty("initialize_op");
		if (props.containsKey("equalizer_op"))
			EQUALIZER = props.getProperty("equalizer_op");
	}

	/**
	 * Create an instance of the algorithm. This simply initializes all the
	 * operators to the default parameters or whatever they are set to in the
	 * passed in properties object. Use {@link #run_population()} to actually
	 * run the population for the specified number of generations.
	 * 
	 * If an invalid operator type is specified, then the program will
	 * terminate, indicating which parameter is incorrect.
	 *
	 * @param props
	 *            Properties object created from a .properties file specifying
	 *            parameters for the algorithm
	 * @param seed
	 *            A seed to use for the RNG. This allows for repeating the same
	 *            trials over again.
	 */
	public AlgorithmBase(Properties props, long seed) {


		loadParams(props);
		create_operators(seed);

		// before we start, publish the stats of the best individual.
		Double f = 0.0;
		for (Individual j : pop) {
			if (j.getFitness() > f) {
				f = j.getFitness();
			}
		}
		System.out.format("gen stats: %3d %.5f " + calculateStats() + "%n", 0, f);
	}

	/**
	 * Empty constructor, to allow subclasses to override
	 */
	public AlgorithmBase() {
	}

	protected void create_operators(long seed) {
		create_operators(seed, null);
	}

	/**
	 * Create all the operators from the loaded params. Seed is the seed to use
	 * for the rng. If specified, d_in is some Data to use. Otherwise, d_in
	 * should be null and fitness will load in the appropriate data.
	 * 
	 * @param seed
	 * @param d_in
	 */
	protected void create_operators(long seed, Data d_in) {
		System.out.println("Running evogpj with seed: " + seed);
		rand = new MersenneTwisterFast(seed);
		
		//initialize
		int SETSIZE = POP_SIZE;
		//int MAX_PRODUCTION_CHOICES = 100;
		ArrayList<ArrayList> SET = new ArrayList<ArrayList>();
		for(int i=0;i<SETSIZE;i++){
			ArrayList<Integer> array = new ArrayList<Integer>();
			for(int j=0;j<MAX_PRODUCTION_CHOICES;j++){
				array.add(rand.nextInt(Integer.MAX_VALUE));
			}
			SET.add(array);
		}

		Graph graph = new Graph();

		if (PROBLEM_TYPE.equals("TaxFunction")) {
			Data d = d_in;
			if (d == null) {
				if (FITNESS.equals("fitness.TaxFitness")) {
					fitness = new TaxFitness(graph,wf);				
				} 
//				ADDED BY JACOB, 1/14/14
				else if (FITNESS.equals("fitness.TaxCodeFitness")) {
					fitness = new TaxCodeFitness(graph,wf);
				}
				else {
					System.err
							.format("Invalid fitness function %s specified for problem type %s%n",
									FITNESS, PROBLEM_TYPE);
					System.exit(-1);
				}
			}
		
		}else if (PROBLEM_TYPE.equals("SRFunction")) {
			Data d = d_in;
			if (d == null) {
				if (FITNESS.equals("fitness.SRFunctionFitness")) {
					d = new FunctionData(rand, PROBLEM, FUNC_SET, TERM_SET);
				} else if (FITNESS.equals("fitness.SRDataFitness")) {
					d = new CSVData(PROBLEM);
					if (TERM_SET == null) {
						TERM_SET = new ArrayList<String>();
						for (int i = 0; i < d.getInputValues().get(0).size(); i++)
							TERM_SET.add("X" + (i + 1));
						System.out.println(TERM_SET);
					}
				} else {
					System.err
							.format("Invalid fitness function %s specified for problem type %s%n",
									FITNESS, PROBLEM_TYPE);
					System.exit(-1);
				}
			}
			fitness = new SRFitness(PNORM, d, PHENOTYPE_DOUBLE);
		} else if (PROBLEM_TYPE.equals("Boolean")) {
			if (FITNESS.equals("fitness.BooleanFitness")) {
				fitness = BooleanFitness
						.constructProblem(PROBLEM, PROBLEM_SIZE);
				if (TERM_SET == null) {
					TERM_SET = new ArrayList<String>();
					for (int i = 0; i < PROBLEM_SIZE; i++) {
						TERM_SET.add("X" + (i + 1));
					}
				}
			} else {
				System.err
						.format("Invalid fitness function %s specified for problem type %s%n",
								FITNESS, PROBLEM_TYPE);
				System.exit(-1);
			}
		} else if (PROBLEM_TYPE.equals("Semantic")) {
			TERM_SET = SemanticFitness.getTerminalSet(PROBLEM_SIZE);
			FUNC_SET = SemanticFitness.getFunctionSet();
			if (FITNESS.equals("fitness.SemanticOrder")) {
				// FIXME parameterise uniform/linear/exponential scaling
				fitness = new SemanticOrder(PROBLEM_SIZE, "uniform");
			} else if (FITNESS.equals("fitness.SemanticMajority")) {
				fitness = new SemanticMajority(PROBLEM_SIZE, "uniform");
			} else {
				System.err
						.format("Invalid fitness function %s specified for problem type %s%n",
								FITNESS, PROBLEM_TYPE);
				System.exit(-1);
			}

		} else {
			System.err.format("Unsupported problem type %s%n", PROBLEM_TYPE);
			System.exit(-1);
		}

		// Set up operators.
		if (SELECT.equals("operator.TournamentSelection")) {
			select = new TournamentSelection(TOURNEY_SIZE, rand);
		} else if (SELECT.equals("operator.TournamentEqualization")) {
			select = new TournamentEqualization(TOURNEY_SIZE, rand);
		} else {
			System.err.format("Invalid select function %s specified%n", SELECT);
			System.exit(-1);
		}
	
		
		if (MUTATE.equals("operator.SubtreeMutate")) {
			mutate = new SubtreeMutate(rand, TREE_MUTATE_MAX_DEPTH);
		}else if(MUTATE.equals("operator.ListMutate")){
			mutate = new ListMutate(rand,POP_SIZE);
		}else {
		
			System.err.format("Invalid mutate function %s specified%n", MUTATE);
			System.exit(-1);
		}
		if (XOVER.equals("operator.BroodSelection")) {
			if (BROOD_SIZE > 1) {
				Crossover broodInternalXover = new SinglePointCrossover(rand,
						TREE_XOVER_MAX_DEPTH, TREE_XOVER_TRIES);
				xover = new BroodSelection(BROOD_SIZE, MUTATION_RATE, fitness,
						broodInternalXover, mutate, rand);
			} else {
				xover = new SinglePointCrossover(rand, TREE_XOVER_MAX_DEPTH,
						TREE_XOVER_TRIES);
			}
		} else if (XOVER.equals("operator.SinglePointCrossover")) {
			xover = new SinglePointCrossover(rand, TREE_XOVER_MAX_DEPTH,
					TREE_XOVER_TRIES);
		}else if (XOVER.equals("operator.ListSinglePointCrossover")){
			xover = new ListSinglePointCrossover(rand);
		}else {
		
			System.err.format("Invalid crossover function %s specified%n",
					XOVER);
			System.exit(-1);
		}

		if (INITIALIZE.equals("operator.TreeInitialize")) {
			initialize = new TreeInitialize(rand, TREE_INITIAL_MAX_DEPTH);
		} else if(INITIALIZE.equals("operator.ListInitialize")){
			System.out.println("Inside ListInitialize");
			initialize = new ListInitialize(rand);
		}else {
		
			System.err.format("Invalid initialize function %s specified%n",
					INITIALIZE);
			System.exit(-1);
		}
		// to set up equalization operator, we need to evaluate all the
		// individuals first
		if(PROBLEM_TYPE.equals("TaxFunction")){
			System.out.println("Initialzing the population");
			pop = initialize.listInitialize(POP_SIZE,SET);
		}else{			
			pop = initialize.initialize(POP_SIZE, FUNC_SET, TERM_SET);
		}
		
		for (Individual i : pop) {
			fitness.eval(i);
			//System.out.println("Fitness of individual: "+i.getGenotype().toString()+" is: "+i.getFitness());
			}
		try {
			if (SELECT.equals("operator.TournamentEqualization")) {
				equalizer = (Equalizer) select;
				equalizer = new TreeDynamicEqualizer(BIN_WIDTH, pop);
			} else if (EQUALIZER.equals("operator.DummyEqualizer")) {
				equalizer = new DummyEqualizer();
			} else if (EQUALIZER.equals("operator.DummyTreeEqualizer")) {
				equalizer = new DummyTreeEqualizer(BIN_WIDTH, pop);
			} else {
				System.err.format("Invalid equalizer function %s specified%n",
						EQUALIZER);
				System.exit(-1);
			}
			equalizer.update(pop);
		} catch (GPException e) {
			e.printStackTrace();
			System.exit(-1);
		}
	}

	/**
	 * Run standard elitism function. The number of best individuals to return
	 * is specified by the <code>elite</code> parameter.
	 * 
	 * @return a Population of size {@link #ELITE} of the top individuals in the
	 *         current {@link #pop}
	 */
	protected Population elitism() {
		System.out.println("INSIDE ELITISM\n");
		LinkedList<Individual> elite = new LinkedList<Individual>();
		Population newPop = new Population();
		if (ELITE == 0)
			return newPop;
		for (int i = 0; i < ELITE; i++) {
			elite.add(pop.get(i));
		}
		Double f;
		for (Individual i : pop) {
			f = i.getFitness();
			for (int j = 0; j < ELITE; j++) {
				if (f > elite.get(j).getFitness()) {
					elite.add(j, i);
					break;
				}
			}
		}
		for (int i = 0; i < ELITE; i++) {
			newPop.add(elite.get(i));
		}
		System.out.println("SIZE OF ELITE: "+ newPop.size());
		return newPop;
	}

	/**
	 * This is the heart of the algorithm. This corresponds to running the
	 * {@link #pop} forward one generation
	 * 
	 * Basically while we still need to produce offspring, we select an
	 * individual (or two) as parent(s) and perform a genetic operator, chosen
	 * at random according to the parameters, to apply to the parent(s) to
	 * produce children. Then evaluate the fitness of the new child(ren) and if
	 * they are accepted by the equalizer, add them to the next generation.
	 * 
	 * @throws GPException
	 *             if any of the operators receive a individual with an
	 *             unexpected genotype, this is an error.
	 */
	public Individual step() throws GPException {
		System.out.println("INSIDE STEP FUNCTION\n");
		Population newPop = elitism();
		equalizer.update(newPop);
		Population children;
		while (newPop.size() < POP_SIZE) {

			Individual p1 = select.select(pop);
			System.out.println("AFTER TOURNAMANET SELECTION INDIVIDUAL GENOTYPE: " + p1.getGenotype().toString());

			String s1;
			children = new Population();
			if (rand.nextDouble() < XOVER_RATE) {
				Individual p2 = select.select(pop);
				//System.out.println("IN XOVER\n");
				System.out.println("P2 INDIVIDUAL GENOTYPE: " + p2.getGenotype().toString());

					children = xover.crossOver(p1, p2);
				
			} else if (rand.nextDouble() < MUTATION_RATE) {
					//System.out.println("IN MUTATION\n");
					children.add(mutate.mutate(p1));
			
			} else {
				//System.out.println("JUST COPY\n");
				
				Individual p4 = p1.copy();
				System.out.println("VALUE AFTER JUST COPY: " + p4.getGenotype().toString());

				children.add(p1.copy());
			}
			for (Individual i : children) {
	
				// each individual should cache it's fitness, so it doesn't hurt
				// to call fitness.eval multiple times per individual.
				fitness.eval(i);
				if (equalizer.accept(i)) {
					newPop.add(i);
				}
			}
		}
		pop = newPop;
		Double f = 0.0;
		Individual best = pop.get(0);
		for (Individual j : pop) {
			if (j.getFitness() > f) {
				f = j.getFitness();
				best = j;
			}
		}
		return best;
	}

	/**
	 * Run the current population for the specified number of generations.
	 * 
	 * @return the best individual found.
	 */
	public Individual run_population() {
		System.out.println("INSIDE RUN POPULATION\n");
		Individual best = null;
		for (int i = 0; i < NUM_GENS; i++) {			
			try {
				best = step();
			} catch (GPException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				continue;
			}
			double f = best.getFitness();
			System.out.println("PRINT THE STATS NOW\n");

			System.out.format("gen stats: %3d %.5f " + calculateStats() + "%n", (i + 1), f);
			System.out.println(best);
			
		}
		return best;
	}

	public boolean done(double fitness) {
		
		return true;
	}

	public static Properties loadProps(String propFile) {
		System.out.println("INSIDE LOAD PROPERTIES");
		Properties props = new Properties();
		BufferedReader f;
		try {
			f = new BufferedReader(new FileReader(propFile));
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
		try {
			props.load(f);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(props.toString());
		return props;
	}
	/*
	 * Main
	 */
	public static void main(String args[]) throws FileNotFoundException {
		
		PrintStream out;
		
		out = new PrintStream(new FileOutputStream("C:\\Users\\Jacob\\Documents\\MIT\\SCOTE\\code\\Tax\\Tax\\src\\interpreter\\output.txt"));

		System.setOut(out);

		
		Properties props = null;
		if (args.length > 0) {
			if(args[0].equals("TaxProperties.properties"))
				props = loadProps(args[0]);
			else{
				grammarFile = args[0];
			}
		}
		if (props == null) {
			props = new Properties();
		}
		
		int num_trials = NUM_TRIALS;
		long seed = System.currentTimeMillis();
		if (props.containsKey("num_trials"))
			num_trials = Integer.valueOf(props.getProperty("num_trials"));
		if (props.containsKey("rng_seed"))
			seed = Integer.parseInt(props.getProperty("rng_seed"));

		AlgorithmBase a;
		for (int i = 0; i < num_trials; i++) {
			System.out.println("running trial " + (i + 1));
			a = new AlgorithmBase(props, seed + i);
			Individual best = a.run_population();
			if (best == null)
				System.out.println("failed");
			else
				System.out.println("terminated with genotype: " + best.getGenotype().toString());
				System.out.println("terminated with phenotype: " + best.getPhenotype().getPhenotype());
		}
	}

	/**
	 * calculate some useful statistics about the current generation of the
	 * population
	 * 
	 * @return String of the following form:
	 *         "avg_fitness fitness_std_dev avg_size size_std_dev"
	 */
	public String calculateStats() {
		Double mean_f = 0.0;
		Double mean_l = 0.0;
		for (Individual i : pop) {
			mean_f += i.getFitness();
			mean_l += i.getGenotype().getGenotype().size();
		}
		mean_f /= pop.size();
		mean_l /= pop.size();
		Double std_f = 0.0;
		Double std_l = 0.0;
		for (Individual i : pop) {
			std_f += Math.pow(i.getFitness() - mean_f, 2);
			std_l += Math.pow(i.getGenotype().getGenotype().size() - mean_l, 2);
		}
		std_f = Math.sqrt(std_f / pop.size());
		std_l = Math.sqrt(std_l / pop.size());
		return String.format("%.5f %.5f %9.5f %9.5f", mean_f, std_f, mean_l,
				std_l);
	}
}
